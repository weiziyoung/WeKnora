# 帷幄系统对接文档 - 批量导入知识库

目前系统没有直接的 **批量上传接口**，需要通过脚本循环调用 **单文件上传接口** 来实现。

## 1. 接口信息

### 1.1 文件上传

- **接口地址**: `POST /api/v1/knowledge-bases/{id}/knowledge/file`
- **Content-Type**: `multipart/form-data`
- **参数**:
    - `file`: 文件对象 (Required)
    - `fileName`: 文件名 (Optional)
    - `enable_multimodel`: 是否启用多模态 (Optional, bool, 默认为 false)
        - **说明**: 该参数主要针对图片文件（如 .png, .jpg）。开启后会使用视觉大模型 (VLM) 对图片内容进行深度解析（如提取文字、描述画面）。
        - **前提**: 系统需配置好对象存储（COS/MinIO）和 VLM 模型。
    - `tag_id`: 分类标签ID (Optional)
        - **说明**: 将上传的知识归类到指定标签（文件夹）。
        - **获取方式**: 调用 `GET /api/v1/knowledge-bases/{id}/tags` 获取标签列表。
- **返回结果 (JSON)**:
    - `success`: 是否成功 (bool)
    - `data`: 知识对象详情
        - `id`: 知识ID (string)
        - `title`: 标题 (string)
        - `parse_status`: 解析状态 (string)
            - `pending`: 等待处理
            - `processing`: 正在处理
            - `completed`: 处理完成
            - `failed`: 处理失败
            - `deleting`: 正在删除
        - `summary_status`: 摘要生成状态 (string, default: "none")
        - `file_name`: 文件名 (string)
        - `file_type`: 文件类型 (string, e.g., "pdf", "docx")
        - `file_size`: 文件大小 (int64, bytes)
        - `file_hash`: 文件哈希值 (string)
        - `file_path`: 文件存储路径 (string)
        - `storage_size`: 存储大小 (int64)
        - `metadata`: 元数据 (object)
        - `enable_status`: 启用状态 (string, "true"|"false")
        - `embedding_model_id`: 嵌入模型ID (string)
        - `error_message`: 错误信息 (string, 仅失败时有值)
        - `created_at`: 创建时间 (string, ISO8601)
        - `updated_at`: 更新时间 (string, ISO8601)
        - `processed_at`: 处理完成时间 (string, ISO8601, nullable)
        - `deleted_at`: 删除时间 (string, nullable)

### 1.2 删除知识

- **接口地址**: `DELETE /api/v1/knowledge/{id}`
- **说明**: 该接口为 **同步接口**。返回成功即表示知识条目及其关联的向量索引、文件文件均已物理删除。
- **返回结果 (JSON)**:
    - `success`: 是否成功 (bool)
    - `message`: 提示信息 (string)

### 1.3 查询知识详情 (查看处理状态)

- **接口地址**: `GET /api/v1/knowledge/{id}`
- **响应参数 (JSON)**:
    - `data.parse_status`: 解析状态 (重要)
        - `pending`: 等待处理
        - `processing`: 正在处理
        - `completed`: 处理完成
        - `failed`: 处理失败
    - `data.error_message`: 如果失败，此处会显示错误信息

### 1.4 获取标签列表

- **接口地址**: `GET /api/v1/knowledge-bases/{id}/tags`
- **响应参数 (JSON)**:
    - `data`: 标签列表数组
        - `id`: 标签ID (用于上传时的 tag_id)
        - `name`: 标签名称

### 1.5 文件上传与解析说明

#### 支持的文件类型
*   **文档**: PDF (`.pdf`), Word (`.doc`, `.docx`), Markdown (`.md`, `.markdown`), Text (`.txt`)
*   **表格**: Excel (`.xlsx`, `.xls`), CSV (`.csv`)
*   **图片**: JPG (`.jpg`, `.jpeg`), PNG (`.png`), GIF (`.gif`)

#### 扫描件 PDF 支持
系统支持扫描件 PDF（图片型 PDF）的解析，但依赖 **MinerU** 服务：
1.  **配置要求**: 必须在 `docreader` 服务中配置 `MINERU_ENDPOINT` 环境变量。
2.  **解析能力**: 配置后支持 OCR 文字识别、表格还原和公式提取。
3.  **降级策略**: 若未配置 MinerU，系统将使用标准解析器（MarkItDown），此时扫描件 PDF 可能无法提取出文本内容。
4.  **图片 OCR**: 直接上传的图片文件（JPG/PNG）使用内置的 PaddleOCR，无需额外配置 MinerU。

#### 1.6 知识库创建流程 (File)

## 2. 批量上传脚本 (Python 示例)

可以使用以下 Python 脚本遍历本地文件夹并逐个上传。

首先安装依赖：
```bash
pip install requests
```

`batch_upload.py` 脚本内容：

```python
import os
import requests
import time

# --- 配置信息 ---
# 根据实际部署地址修改，如果是本地启动通常是 8080 或 80
API_HOST = "http://localhost:8080"
# 替换为你的知识库 ID (在浏览器地址栏可以看到)
KB_ID = "YOUR_KNOWLEDGE_BASE_ID"
# 替换为你的 API Key (如果没有开启认证可忽略 Authorization 头)
API_KEY = "YOUR_API_KEY"
# 你要上传的本地文件夹路径
LOCAL_DIR = "./documents"
# (可选) 指定上传到的标签 ID
TAG_ID = "" 

# 支持的文件类型
SUPPORTED_EXTENSIONS = {'.pdf', '.docx', '.doc', '.txt', '.md', '.markdown', '.csv', '.xlsx', '.xls', '.png', '.jpg', '.jpeg', '.gif'}

def upload_file(file_path):
    filename = os.path.basename(file_path)
    print(f"正在上传: {filename} ...")
    
    url = f"{API_HOST}/api/v1/knowledge-bases/{KB_ID}/knowledge/file"
    headers = {
        # 如果系统开启了认证，请取消下面注释并填入 Token
        # "Authorization": f"Bearer {API_KEY}" 
    }
    
    try:
        with open(file_path, 'rb') as f:
            files = {
                'file': (filename, f)
            }
            # 可选参数
            data = {
                # 是否开启多模态解析 (主要用于图片)
                'enable_multimodel': 'false',
                # 传入标签 ID
                'tag_id': TAG_ID
            }
            
            response = requests.post(url, headers=headers, files=files, data=data)
            
            if response.status_code == 200:
                result = response.json()
                if result.get('success'):
                    knowledge_id = result['data']['id']
                    print(f"✅ 上传成功: {filename} (ID: {knowledge_id})")
                    # 可选：立即查询一次状态
                    # check_status(knowledge_id)
                else:
                     print(f"❌ 上传失败: {filename}, 错误: {result.get('message')}")
            else:
                print(f"❌ 上传失败: {filename}, 状态码: {response.status_code}, 错误: {response.text}")
                
    except Exception as e:
        print(f"❌ 上传出错: {filename}, 异常: {e}")

def check_status(knowledge_id):
    url = f"{API_HOST}/api/v1/knowledge/{knowledge_id}"
    headers = {
        # "Authorization": f"Bearer {API_KEY}" 
    }
    try:
        response = requests.get(url, headers=headers)
        if response.status_code == 200:
            data = response.json().get('data', {})
            status = data.get('parse_status')
            print(f"   -> 当前状态: {status}")
        else:
            print(f"   -> 查询状态失败: {response.status_code}")
    except Exception as e:
        print(f"   -> 查询状态出错: {e}")

def main():
    if not os.path.exists(LOCAL_DIR):
        print(f"目录不存在: {LOCAL_DIR}")
        return

    count = 0
    for root, dirs, files in os.walk(LOCAL_DIR):
        for file in files:
            # 检查文件后缀
            ext = os.path.splitext(file)[1].lower()
            if ext in SUPPORTED_EXTENSIONS:
                file_path = os.path.join(root, file)
                upload_file(file_path)
                count += 1
                # 稍微延时，避免请求过快
                time.sleep(0.1)
            else:
                print(f"⚠️ 跳过不支持的文件类型: {file}")
                
    print(f"\n处理完成，共尝试上传 {count} 个文件。")

if __name__ == "__main__":
    main()
```

## 3. 处理流程说明

当你调用该接口上传文件后，后端会自动执行以下流程：

1.  **文件存储**: 文件会被保存到配置的存储服务（本地磁盘、MinIO 或 COS）。
    - **关于本地磁盘 (Local Disk)**:
        - **Docker 环境**: 默认映射路径为容器内的 `/data/files`。该路径对应宿主机的 Docker Volume（默认卷名为 `weknora_data-files` 或 `data-files`，具体取决于 docker-compose 的项目名称），可通过命令 `docker volume inspect <volume_name>` 查看宿主机上的具体物理路径。
        - **非 Docker 环境**: 取决于环境变量 `LOCAL_STORAGE_BASE_DIR` 的配置。
            - 如果未设置该环境变量，文件将存储在运行目录下的相对路径中。
            - 如果设置了该环境变量（如 `LOCAL_STORAGE_BASE_DIR=/data/files`），则存储在指定的绝对路径下。
2.  **异步解析**: 系统会创建一个异步任务 (`types.TypeDocumentProcess`) 放入消息队列。
3.  **文档解析**: `docreader` 服务会根据文件类型（PDF, Word, Excel 等）提取文本。
4.  **切片与向量化**: 文本会被切分成 Chunk，计算向量，并存入向量数据库。
5.  **状态更新**: 
    - 初始状态为 `pending`
    - 开始解析变为 `processing`
    - 解析成功变为 `completed`
    - 失败则变为 `failed`

你只需要保证文件上传成功 (HTTP 200)，后续的 RAG 处理（解析、切片、索引）都是自动完成的。可以通过 `GET /api/v1/knowledge/{id}` 接口轮询查看处理进度。

### 1.7 MinerU 配置 (扫描件 OCR 支持)

MinerU 是一个基于深度学习的文档解析工具，特别擅长处理扫描版 PDF、复杂表格和公式提取。WeKnora 通过集成 MinerU API 来支持这些高级功能。

**适用场景**:
- 上传扫描版 PDF（图片转文字）
- 需要高精度提取表格和公式

**部署方式**:
-   配置 WeKnora:
    在 `.env` 文件中添加或修改:
    ```bash
    MINERU_ENDPOINT=http://<mineru-host>:8000
    # 如果 mineru 和 weknora 在同一台机器的 docker 中运行，可以使用 http://mineru-api:8000 (需在同一网络下)
        ```

**验证配置**:
1.  访问 `http://<mineru-host>:8000/docs` 确认 MinerU API 服务已启动。
2.  在 WeKnora 中上传一个扫描版 PDF，观察 `docreader` 服务日志，应能看到调用 MinerU API 的记录。
